CCS PCM C Compiler, Version 5.015, 5967               12-ago-23 16:46

               Filename:   C:\Users\aliba\Desktop\Proj final Lab\Projeto final\Projeto final\symon.lst

               ROM used:   2315 words (28%)
                           Largest free fragment is 2048
               RAM used:   84 (23%) at main() level
                           203 (55%) worst case
               Stack used: 7 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #import(file="simon.o") 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA 0C,00
0005:  DATA D7,32
0006:  DATA EC,31
0007:  DATA EF,36
0008:  DATA 65,10
0009:  DATA F4,37
000A:  DATA A0,29
000B:  DATA E9,36
000C:  DATA 6F,37
000D:  DATA 00,01
000E:  DATA 50,39
000F:  DATA E5,39
0010:  DATA 73,10
0011:  DATA 53,3A
0012:  DATA 61,39
0013:  DATA F4,10
0014:  DATA 00,00
0015:  DATA C7,20
0016:  DATA CD,22
0017:  DATA A0,27
0018:  DATA D6,22
0019:  DATA D2,10
001A:  DATA 00,00
001B:  DATA 53,34
001C:  DATA EF,3B
001D:  DATA 69,37
001E:  DATA 67,10
001F:  DATA 74,34
0020:  DATA 65,10
0021:  DATA F3,32
0022:  DATA F1,10
0023:  DATA 00,01
0024:  DATA CE,37
0025:  DATA 77,10
0026:  DATA 69,3A
0027:  DATA A7,39
0028:  DATA A0,29
0029:  DATA E9,36
002A:  DATA 6F,37
002B:  DATA 21,00
002C:  DATA CE,37
002D:  DATA 77,10
002E:  DATA 69,3A
002F:  DATA A7,39
0030:  DATA A0,2C
0031:  DATA EF,3A
0032:  DATA 21,00
0033:  DATA 55,10
0034:  DATA E7,37
0035:  DATA 74,10
0036:  DATA 69,3A
0037:  DATA 20,39
0038:  DATA E9,33
0039:  DATA 68,3A
003A:  DATA 21,00
003B:  DATA 49,3A
003C:  DATA A7,39
003D:  DATA A0,3A
003E:  DATA 72,10
003F:  DATA F4,3A
0040:  DATA 72,37
0041:  DATA 21,1D
0042:  DATA 29,00
0043:  DATA 45,37
0044:  DATA F4,32
0045:  DATA 72,10
0046:  DATA 61,10
0047:  DATA F6,30
0048:  DATA EC,3A
0049:  DATA 65,00
004A:  DATA F4,37
004B:  DATA A0,30
004C:  DATA 64,32
004D:  DATA 20,3A
004E:  DATA 6F,10
004F:  DATA 74,34
0050:  DATA 65,00
0051:  DATA F3,32
0052:  DATA F1,3A
0053:  DATA 65,37
0054:  DATA E3,32
0055:  DATA 21,00
0056:  DATA 50,39
0057:  DATA E5,39
0058:  DATA 73,10
0059:  DATA 6F,37
005A:  DATA E5,10
005B:  DATA 20,1D
005C:  DATA 29,00
*
015D:  MOVLW  20
015E:  BSF    03.5
015F:  MOVWF  24
0160:  CLRF   20
0161:  CLRF   21
0162:  CLRF   22
0163:  CLRF   23
0164:  MOVF   72,W
0165:  MOVWF  7A
0166:  MOVF   71,W
0167:  MOVWF  79
0168:  MOVF   70,W
0169:  MOVWF  78
016A:  BCF    03.5
016B:  MOVF   6F,W
016C:  MOVWF  77
016D:  BCF    03.0
016E:  BTFSS  77.0
016F:  GOTO   180
0170:  MOVF   73,W
0171:  BSF    03.5
0172:  ADDWF  20,F
0173:  MOVF   74,W
0174:  BTFSC  03.0
0175:  INCFSZ 74,W
0176:  ADDWF  21,F
0177:  MOVF   75,W
0178:  BTFSC  03.0
0179:  INCFSZ 75,W
017A:  ADDWF  22,F
017B:  MOVF   76,W
017C:  BTFSC  03.0
017D:  INCFSZ 76,W
017E:  ADDWF  23,F
017F:  BCF    03.5
0180:  BSF    03.5
0181:  RRF    23,F
0182:  RRF    22,F
0183:  RRF    21,F
0184:  RRF    20,F
0185:  RRF    7A,F
0186:  RRF    79,F
0187:  RRF    78,F
0188:  RRF    77,F
0189:  DECFSZ 24,F
018A:  GOTO   18C
018B:  GOTO   18E
018C:  BCF    03.5
018D:  GOTO   16D
*
01B8:  CLRF   78
01B9:  CLRF   79
01BA:  CLRF   77
01BB:  CLRF   7A
01BC:  MOVF   75,W
01BD:  BTFSS  03.2
01BE:  GOTO   1C2
01BF:  MOVF   74,W
01C0:  BTFSC  03.2
01C1:  GOTO   1DC
01C2:  MOVLW  10
01C3:  MOVWF  76
01C4:  BCF    03.0
01C5:  RLF    72,F
01C6:  RLF    73,F
01C7:  RLF    77,F
01C8:  RLF    7A,F
01C9:  MOVF   75,W
01CA:  SUBWF  7A,W
01CB:  BTFSS  03.2
01CC:  GOTO   1CF
01CD:  MOVF   74,W
01CE:  SUBWF  77,W
01CF:  BTFSS  03.0
01D0:  GOTO   1D8
01D1:  MOVF   74,W
01D2:  SUBWF  77,F
01D3:  BTFSS  03.0
01D4:  DECF   7A,F
01D5:  MOVF   75,W
01D6:  SUBWF  7A,F
01D7:  BSF    03.0
01D8:  RLF    78,F
01D9:  RLF    79,F
01DA:  DECFSZ 76,F
01DB:  GOTO   1C4
*
0251:  MOVF   0B,W
0252:  BSF    03.5
0253:  MOVWF  67
0254:  BCF    03.5
0255:  BCF    0B.7
0256:  BSF    03.5
0257:  BSF    03.6
0258:  BSF    0C.7
0259:  BSF    0C.0
025A:  NOP
025B:  NOP
025C:  BCF    03.6
025D:  BTFSS  67.7
025E:  GOTO   262
025F:  BCF    03.5
0260:  BSF    0B.7
0261:  BSF    03.5
0262:  BCF    03.5
0263:  BSF    03.6
0264:  MOVF   0C,W
0265:  ANDLW  7F
0266:  BTFSC  03.2
0267:  GOTO   2C3
0268:  BSF    03.5
0269:  BCF    03.6
026A:  MOVWF  67
026B:  BCF    03.5
026C:  BSF    03.6
026D:  MOVF   0D,W
026E:  BSF    03.5
026F:  BCF    03.6
0270:  MOVWF  68
0271:  BCF    03.5
0272:  BSF    03.6
0273:  MOVF   0F,W
0274:  BSF    03.5
0275:  BCF    03.6
0276:  MOVWF  69
0277:  MOVF   67,W
0278:  MOVWF  6A
0279:  BCF    03.5
027A:  CALL   211
027B:  BSF    03.5
027C:  MOVF   68,W
027D:  BCF    03.5
027E:  BSF    03.6
027F:  MOVWF  0D
0280:  BSF    03.5
0281:  BCF    03.6
0282:  MOVF   69,W
0283:  BCF    03.5
0284:  BSF    03.6
0285:  MOVWF  0F
0286:  BCF    03.6
0287:  MOVF   0B,W
0288:  BSF    03.5
0289:  MOVWF  6A
028A:  BCF    03.5
028B:  BCF    0B.7
028C:  BSF    03.5
028D:  BSF    03.6
028E:  BSF    0C.7
028F:  BSF    0C.0
0290:  NOP
0291:  NOP
0292:  BCF    03.6
0293:  BTFSS  6A.7
0294:  GOTO   298
0295:  BCF    03.5
0296:  BSF    0B.7
0297:  BSF    03.5
0298:  BCF    03.5
0299:  BSF    03.6
029A:  RLF    0C,W
029B:  RLF    0E,W
029C:  ANDLW  7F
029D:  BTFSC  03.2
029E:  GOTO   2C3
029F:  BSF    03.5
02A0:  BCF    03.6
02A1:  MOVWF  67
02A2:  BCF    03.5
02A3:  BSF    03.6
02A4:  MOVF   0D,W
02A5:  BSF    03.5
02A6:  BCF    03.6
02A7:  MOVWF  68
02A8:  BCF    03.5
02A9:  BSF    03.6
02AA:  MOVF   0F,W
02AB:  BSF    03.5
02AC:  BCF    03.6
02AD:  MOVWF  69
02AE:  MOVF   67,W
02AF:  MOVWF  6A
02B0:  BCF    03.5
02B1:  CALL   211
02B2:  BSF    03.5
02B3:  MOVF   68,W
02B4:  BCF    03.5
02B5:  BSF    03.6
02B6:  MOVWF  0D
02B7:  BSF    03.5
02B8:  BCF    03.6
02B9:  MOVF   69,W
02BA:  BCF    03.5
02BB:  BSF    03.6
02BC:  MOVWF  0F
02BD:  INCF   0D,F
02BE:  BTFSC  03.2
02BF:  INCF   0F,F
02C0:  BCF    03.6
02C1:  GOTO   251
02C2:  BSF    03.6
02C3:  BCF    03.6
02C4:  RETURN
*
02D2:  BSF    03.6
02D3:  MOVF   1D,W
02D4:  BTFSC  03.2
02D5:  GOTO   398
02D6:  MOVWF  29
02D7:  MOVF   21,W
02D8:  BTFSC  03.2
02D9:  GOTO   398
02DA:  SUBWF  29,F
02DB:  BTFSS  03.0
02DC:  GOTO   2E2
02DD:  MOVLW  7F
02DE:  ADDWF  29,F
02DF:  BTFSC  03.0
02E0:  GOTO   398
02E1:  GOTO   2E8
02E2:  MOVLW  81
02E3:  SUBWF  29,F
02E4:  BTFSS  03.0
02E5:  GOTO   398
02E6:  BTFSC  03.2
02E7:  GOTO   398
02E8:  MOVF   29,W
02E9:  MOVWF  77
02EA:  CLRF   78
02EB:  CLRF   79
02EC:  CLRF   7A
02ED:  CLRF   28
02EE:  MOVF   1E,W
02EF:  MOVWF  27
02F0:  BSF    27.7
02F1:  MOVF   1F,W
02F2:  MOVWF  26
02F3:  MOVF   20,W
02F4:  MOVWF  25
02F5:  MOVLW  19
02F6:  MOVWF  29
02F7:  MOVF   24,W
02F8:  SUBWF  25,F
02F9:  BTFSC  03.0
02FA:  GOTO   30B
02FB:  MOVLW  01
02FC:  SUBWF  26,F
02FD:  BTFSC  03.0
02FE:  GOTO   30B
02FF:  SUBWF  27,F
0300:  BTFSC  03.0
0301:  GOTO   30B
0302:  SUBWF  28,F
0303:  BTFSC  03.0
0304:  GOTO   30B
0305:  INCF   28,F
0306:  INCF   27,F
0307:  INCF   26,F
0308:  MOVF   24,W
0309:  ADDWF  25,F
030A:  GOTO   33D
030B:  MOVF   23,W
030C:  SUBWF  26,F
030D:  BTFSC  03.0
030E:  GOTO   326
030F:  MOVLW  01
0310:  SUBWF  27,F
0311:  BTFSC  03.0
0312:  GOTO   326
0313:  SUBWF  28,F
0314:  BTFSC  03.0
0315:  GOTO   326
0316:  INCF   28,F
0317:  INCF   27,F
0318:  MOVF   23,W
0319:  ADDWF  26,F
031A:  MOVF   24,W
031B:  ADDWF  25,F
031C:  BTFSS  03.0
031D:  GOTO   33D
031E:  INCF   26,F
031F:  BTFSS  03.2
0320:  GOTO   33D
0321:  INCF   27,F
0322:  BTFSS  03.2
0323:  GOTO   33D
0324:  INCF   28,F
0325:  GOTO   33D
0326:  MOVF   22,W
0327:  IORLW  80
0328:  SUBWF  27,F
0329:  BTFSC  03.0
032A:  GOTO   33C
032B:  MOVLW  01
032C:  SUBWF  28,F
032D:  BTFSC  03.0
032E:  GOTO   33C
032F:  INCF   28,F
0330:  MOVF   22,W
0331:  IORLW  80
0332:  ADDWF  27,F
0333:  MOVF   23,W
0334:  ADDWF  26,F
0335:  BTFSS  03.0
0336:  GOTO   31A
0337:  INCF   27,F
0338:  BTFSS  03.2
0339:  GOTO   31A
033A:  INCF   28,F
033B:  GOTO   31A
033C:  BSF    7A.0
033D:  DECFSZ 29,F
033E:  GOTO   340
033F:  GOTO   34B
0340:  BCF    03.0
0341:  RLF    25,F
0342:  RLF    26,F
0343:  RLF    27,F
0344:  RLF    28,F
0345:  BCF    03.0
0346:  RLF    7A,F
0347:  RLF    79,F
0348:  RLF    78,F
0349:  RLF    2A,F
034A:  GOTO   2F7
034B:  BTFSS  2A.0
034C:  GOTO   353
034D:  BCF    03.0
034E:  RRF    78,F
034F:  RRF    79,F
0350:  RRF    7A,F
0351:  RRF    2A,F
0352:  GOTO   356
0353:  DECF   77,F
0354:  BTFSC  03.2
0355:  GOTO   398
0356:  BTFSC  2A.7
0357:  GOTO   37F
0358:  BCF    03.0
0359:  RLF    25,F
035A:  RLF    26,F
035B:  RLF    27,F
035C:  RLF    28,F
035D:  MOVF   24,W
035E:  SUBWF  25,F
035F:  BTFSC  03.0
0360:  GOTO   36B
0361:  MOVLW  01
0362:  SUBWF  26,F
0363:  BTFSC  03.0
0364:  GOTO   36B
0365:  SUBWF  27,F
0366:  BTFSC  03.0
0367:  GOTO   36B
0368:  SUBWF  28,F
0369:  BTFSS  03.0
036A:  GOTO   38E
036B:  MOVF   23,W
036C:  SUBWF  26,F
036D:  BTFSC  03.0
036E:  GOTO   376
036F:  MOVLW  01
0370:  SUBWF  27,F
0371:  BTFSC  03.0
0372:  GOTO   376
0373:  SUBWF  28,F
0374:  BTFSS  03.0
0375:  GOTO   38E
0376:  MOVF   22,W
0377:  IORLW  80
0378:  SUBWF  27,F
0379:  BTFSC  03.0
037A:  GOTO   37F
037B:  MOVLW  01
037C:  SUBWF  28,F
037D:  BTFSS  03.0
037E:  GOTO   38E
037F:  INCF   7A,F
0380:  BTFSS  03.2
0381:  GOTO   38E
0382:  INCF   79,F
0383:  BTFSS  03.2
0384:  GOTO   38E
0385:  INCF   78,F
0386:  BTFSS  03.2
0387:  GOTO   38E
0388:  INCF   77,F
0389:  BTFSC  03.2
038A:  GOTO   398
038B:  RRF    78,F
038C:  RRF    79,F
038D:  RRF    7A,F
038E:  MOVF   1E,W
038F:  MOVWF  29
0390:  MOVF   22,W
0391:  XORWF  29,F
0392:  BTFSS  29.7
0393:  GOTO   396
0394:  BSF    78.7
0395:  GOTO   39C
0396:  BCF    78.7
0397:  GOTO   39C
0398:  CLRF   77
0399:  CLRF   78
039A:  CLRF   79
039B:  CLRF   7A
039C:  BCF    03.6
039D:  RETURN
039E:  MOVLW  8E
039F:  MOVWF  77
03A0:  BSF    03.6
03A1:  MOVF   19,W
03A2:  SUBWF  77,F
03A3:  MOVF   1A,W
03A4:  MOVWF  79
03A5:  MOVF   1B,W
03A6:  MOVWF  78
03A7:  BSF    79.7
03A8:  MOVF   77,F
03A9:  BTFSC  03.2
03AA:  GOTO   3B6
03AB:  BCF    03.0
03AC:  MOVF   79,F
03AD:  BTFSS  03.2
03AE:  GOTO   3B2
03AF:  MOVF   78,F
03B0:  BTFSC  03.2
03B1:  GOTO   3B6
03B2:  RRF    79,F
03B3:  RRF    78,F
03B4:  DECFSZ 77,F
03B5:  GOTO   3AB
03B6:  BTFSS  1A.7
03B7:  GOTO   3BD
03B8:  COMF   78,F
03B9:  COMF   79,F
03BA:  INCF   78,F
03BB:  BTFSC  03.2
03BC:  INCF   79,F
03BD:  BCF    03.6
03BE:  RETURN
*
040A:  MOVLW  8E
040B:  MOVWF  77
040C:  MOVF   1A,W
040D:  MOVWF  78
040E:  MOVF   19,W
040F:  MOVWF  79
0410:  CLRF   7A
0411:  MOVF   78,F
0412:  BTFSS  03.2
0413:  GOTO   41E
0414:  MOVF   79,W
0415:  MOVWF  78
0416:  CLRF   79
0417:  MOVLW  08
0418:  SUBWF  77,F
0419:  MOVF   78,F
041A:  BTFSS  03.2
041B:  GOTO   41E
041C:  CLRF   77
041D:  GOTO   426
041E:  BCF    03.0
041F:  BTFSC  78.7
0420:  GOTO   425
0421:  RLF    79,F
0422:  RLF    78,F
0423:  DECF   77,F
0424:  GOTO   41E
0425:  BCF    78.7
*
0446:  MOVF   19,W
0447:  BTFSC  03.2
0448:  GOTO   4B6
0449:  MOVWF  21
044A:  MOVF   1D,W
044B:  BTFSC  03.2
044C:  GOTO   4B6
044D:  ADDWF  21,F
044E:  BTFSC  03.0
044F:  GOTO   457
0450:  MOVLW  7F
0451:  SUBWF  21,F
0452:  BTFSS  03.0
0453:  GOTO   4B6
0454:  BTFSC  03.2
0455:  GOTO   4B6
0456:  GOTO   45B
0457:  MOVLW  81
0458:  ADDWF  21,F
0459:  BTFSC  03.0
045A:  GOTO   4B6
045B:  MOVF   21,W
045C:  MOVWF  77
045D:  CLRF   78
045E:  CLRF   79
045F:  CLRF   7A
0460:  MOVF   1A,W
0461:  MOVWF  25
0462:  BSF    25.7
0463:  MOVF   1B,W
0464:  MOVWF  24
0465:  MOVF   1C,W
0466:  MOVWF  23
0467:  MOVLW  18
0468:  MOVWF  21
0469:  CLRF   22
046A:  BTFSS  23.0
046B:  GOTO   484
046C:  MOVF   20,W
046D:  ADDWF  7A,F
046E:  BTFSS  03.0
046F:  GOTO   476
0470:  INCF   79,F
0471:  BTFSS  03.2
0472:  GOTO   476
0473:  INCF   78,F
0474:  BTFSC  03.2
0475:  BSF    22.7
0476:  MOVF   1F,W
0477:  ADDWF  79,F
0478:  BTFSS  03.0
0479:  GOTO   47D
047A:  INCF   78,F
047B:  BTFSC  03.2
047C:  BSF    22.7
047D:  MOVF   1E,W
047E:  MOVWF  1B
047F:  BSF    1B.7
0480:  MOVF   1B,W
0481:  ADDWF  78,F
0482:  BTFSC  03.0
0483:  BSF    22.7
0484:  RLF    22,F
0485:  RRF    78,F
0486:  RRF    79,F
0487:  RRF    7A,F
0488:  RRF    25,F
0489:  RRF    24,F
048A:  RRF    23,F
048B:  BCF    03.0
048C:  DECFSZ 21,F
048D:  GOTO   469
048E:  MOVLW  01
048F:  ADDWF  77,F
0490:  BTFSC  03.0
0491:  GOTO   4B6
0492:  BTFSC  78.7
0493:  GOTO   49B
0494:  RLF    25,F
0495:  RLF    7A,F
0496:  RLF    79,F
0497:  RLF    78,F
0498:  DECF   77,F
0499:  BTFSC  03.2
049A:  GOTO   4B6
049B:  BTFSS  25.7
049C:  GOTO   4AC
049D:  INCF   7A,F
049E:  BTFSS  03.2
049F:  GOTO   4AC
04A0:  INCF   79,F
04A1:  BTFSS  03.2
04A2:  GOTO   4AC
04A3:  INCF   78,F
04A4:  BTFSS  03.2
04A5:  GOTO   4AC
04A6:  RRF    78,F
04A7:  RRF    79,F
04A8:  RRF    7A,F
04A9:  INCF   77,F
04AA:  BTFSC  03.2
04AB:  GOTO   4B6
04AC:  MOVF   1A,W
04AD:  MOVWF  22
04AE:  MOVF   1E,W
04AF:  XORWF  22,F
04B0:  BTFSS  22.7
04B1:  GOTO   4B4
04B2:  BSF    78.7
04B3:  GOTO   4BA
04B4:  BCF    78.7
04B5:  GOTO   4BA
04B6:  CLRF   77
04B7:  CLRF   78
04B8:  CLRF   79
04B9:  CLRF   7A
*
0657:  BCF    0A.0
0658:  BSF    0A.1
0659:  BSF    0A.2
065A:  ADDWF  02,F
065B:  GOTO   5D8
065C:  GOTO   5F7
065D:  GOTO   616
065E:  GOTO   636
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
*
080A:  CLRF   20
080B:  CLRF   21
080C:  BCF    03.7
080D:  BSF    03.5
080E:  BSF    1F.0
080F:  BSF    1F.1
0810:  BSF    1F.2
0811:  BCF    1F.3
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
014D:  MOVF   25,W
014E:  MOVWF  72
014F:  MOVF   24,W
0150:  MOVWF  71
0151:  MOVF   23,W
0152:  MOVWF  70
0153:  MOVF   22,W
0154:  MOVWF  6F
0155:  MOVLW  41
0156:  MOVWF  76
0157:  MOVLW  C6
0158:  MOVWF  75
0159:  MOVLW  4E
015A:  MOVWF  74
015B:  MOVLW  6D
015C:  MOVWF  73
*
018E:  MOVF   77,W
018F:  BCF    03.5
0190:  MOVWF  6F
0191:  MOVLW  39
0192:  ADDWF  6F,W
0193:  MOVWF  22
0194:  MOVF   78,W
0195:  MOVWF  23
0196:  MOVLW  30
0197:  BTFSC  03.0
0198:  MOVLW  31
0199:  ADDWF  23,F
019A:  MOVF   79,W
019B:  MOVWF  24
019C:  MOVLW  00
019D:  BTFSC  03.0
019E:  MOVLW  01
019F:  ADDWF  24,F
01A0:  MOVF   7A,W
01A1:  MOVWF  25
01A2:  MOVLW  00
01A3:  BTFSC  03.0
01A4:  MOVLW  01
01A5:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
01A6:  MOVF   24,W
01A7:  MOVWF  77
01A8:  MOVF   25,W
01A9:  MOVWF  78
01AA:  CLRF   79
01AB:  CLRF   7A
01AC:  MOVF   78,W
01AD:  MOVWF  71
01AE:  MOVF   77,W
01AF:  MOVWF  70
01B0:  MOVF   71,W
01B1:  MOVWF  73
01B2:  MOVF   70,W
01B3:  MOVWF  72
01B4:  MOVLW  7F
01B5:  MOVWF  75
01B6:  MOVLW  FF
01B7:  MOVWF  74
*
01DC:  MOVF   77,W
01DD:  MOVWF  78
01DE:  MOVF   7A,W
01DF:  MOVWF  79
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #use delay(clock=20000000) 
*
005D:  MOVLW  EB
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   070
0063:  MOVLW  06
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  7B
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  DECFSZ 00,F
006F:  GOTO   063
0070:  RETURN
*
03BF:  MOVLW  03
03C0:  BSF    03.6
03C1:  SUBWF  1A,F
03C2:  BTFSS  03.0
03C3:  GOTO   3CE
03C4:  MOVLW  1A
03C5:  MOVWF  04
03C6:  BSF    03.7
03C7:  MOVF   00,W
03C8:  BTFSC  03.2
03C9:  GOTO   3CE
03CA:  GOTO   3CC
03CB:  GOTO   3CC
03CC:  DECFSZ 00,F
03CD:  GOTO   3CB
03CE:  BCF    03.6
03CF:  RETURN
.................... #fuses xt, nowdt, nolvp 
.................... #include "lcd.c" 
.................... #device PIC16F877A 
.................... #use delay(clock = 20000000) 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_cycles(1); 
....................    high = lcd_read_nibble(); 
....................        
....................    lcd_output_enable(0); 
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_us(1); 
....................    low = lcd_read_nibble(); 
....................        
....................    lcd_output_enable(0); 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
....................    lcd_output_enable(1); 
....................    delay_us(2); 
....................    lcd_output_enable(0); 
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
....................    lcd_rs_tris(); 
....................    lcd_rw_tris(); 
....................   #endif 
....................  
....................    lcd_output_rs(0); 
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
....................    lcd_output_rs(address); 
....................    delay_cycles(1); 
....................    lcd_output_rw(0); 
....................    delay_cycles(1); 
....................    lcd_output_enable(0); 
....................    lcd_send_nibble(n >> 4); 
....................    lcd_send_nibble(n & 0xf); 
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
....................    lcd_output_rs(0); 
....................    lcd_output_rw(0); 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
....................    lcd_rs_tris(); 
....................    lcd_rw_tris(); 
....................  #endif 
....................      
....................    delay_ms(15); 
....................    for(i=1;i<=3;++i) 
....................    { 
....................        lcd_send_nibble(3); 
....................        delay_ms(5); 
....................    } 
....................     
....................    lcd_send_nibble(2); 
....................    delay_ms(5); 
....................    for(i=0;i<=3;++i) 
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
....................       address=LCD_LINE_TWO; 
....................    else 
....................       address=0; 
....................       
....................    address+=x-1; 
....................    lcd_send_byte(0,0x80|address); 
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
....................                      delay_ms(2); 
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
....................      #endif 
....................    } 
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... // para o display 7seg 
.................... //int display[10] = {(0b0111111), (0b0000110), (0b1011011), (0b1001111), (0b1100110), (0b1101101), (0b1111101), (0b0000111), (0b1111111), (0b1101111)};   
.................... #define LCD_ENABLE_PIN  PIN_B0   
.................... #define LCD_RS_PIN      PIN_B1   
.................... #define LCD_RW_PIN      PIN_B2   
.................... #define LCD_DATA4       PIN_B4    
.................... #define LCD_DATA5       PIN_B5    
.................... #define LCD_DATA6       PIN_B6       
.................... #define LCD_DATA7       PIN_B7 
....................  
.................... // botoes 
.................... #define B1 PIN_C0 
.................... #define B2 PIN_C1 
.................... #define B3 PIN_C2 
.................... #define B4 PIN_C3 
....................  
.................... // leds 
.................... #define BLUE PIN_A0 
.................... #define YELLOW PIN_A1 
.................... #define RED PIN_A2 
.................... #define GREEN PIN_A3 
....................  
.................... // buzzer 
.................... #define BUZZER_PIN PIN_C4 
....................  
.................... // start 
.................... #define START_PIN PIN_C5 
....................  
....................  
.................... //We declare a var to save the sequence that simon will use 
.................... //The current sequence is generated when the player starts a new game 
.................... int seq[32]; 
.................... int player_seq[32]; 
.................... int nivel = 0; 
.................... int start = 0; 
.................... int acertou = 0; 
.................... int errou = 0; 
.................... //=============Buzzer==================== 
.................... void playTone(float frequency, unsigned int duration) { 
03D0:  BSF    03.6
03D1:  CLRF   20
03D2:  MOVLW  24
03D3:  MOVWF  1F
03D4:  MOVLW  74
03D5:  MOVWF  1E
03D6:  MOVLW  92
03D7:  MOVWF  1D
03D8:  BSF    03.5
03D9:  BCF    03.6
03DA:  MOVF   6F,W
03DB:  BCF    03.5
03DC:  BSF    03.6
03DD:  MOVWF  24
03DE:  BSF    03.5
03DF:  BCF    03.6
03E0:  MOVF   6E,W
03E1:  BCF    03.5
03E2:  BSF    03.6
03E3:  MOVWF  23
03E4:  BSF    03.5
03E5:  BCF    03.6
03E6:  MOVF   6D,W
03E7:  BCF    03.5
03E8:  BSF    03.6
03E9:  MOVWF  22
03EA:  BSF    03.5
03EB:  BCF    03.6
03EC:  MOVF   6C,W
03ED:  BCF    03.5
03EE:  BSF    03.6
03EF:  MOVWF  21
03F0:  BCF    03.6
03F1:  CALL   2D2
03F2:  MOVF   7A,W
03F3:  BSF    03.6
03F4:  MOVWF  1C
03F5:  MOVF   79,W
03F6:  MOVWF  1B
03F7:  MOVF   78,W
03F8:  MOVWF  1A
03F9:  MOVF   77,W
03FA:  MOVWF  19
03FB:  BCF    03.6
03FC:  CALL   39E
03FD:  MOVF   79,W
03FE:  BSF    03.6
03FF:  MOVWF  12
0400:  MOVF   78,W
0401:  MOVWF  11
0402:  BCF    03.0
0403:  RRF    12,W
0404:  MOVWF  14
0405:  RRF    11,W
0406:  MOVWF  13
0407:  CLRF   1A
0408:  MOVF   10,W
0409:  MOVWF  19
*
0426:  BSF    03.5
0427:  BCF    03.6
0428:  MOVF   6F,W
0429:  BCF    03.5
042A:  BSF    03.6
042B:  MOVWF  1C
042C:  BSF    03.5
042D:  BCF    03.6
042E:  MOVF   6E,W
042F:  BCF    03.5
0430:  BSF    03.6
0431:  MOVWF  1B
0432:  BSF    03.5
0433:  BCF    03.6
0434:  MOVF   6D,W
0435:  BCF    03.5
0436:  BSF    03.6
0437:  MOVWF  1A
0438:  BSF    03.5
0439:  BCF    03.6
043A:  MOVF   6C,W
043B:  BCF    03.5
043C:  BSF    03.6
043D:  MOVWF  19
043E:  MOVF   7A,W
043F:  MOVWF  20
0440:  MOVF   79,W
0441:  MOVWF  1F
0442:  MOVF   78,W
0443:  MOVWF  1E
0444:  MOVF   77,W
0445:  MOVWF  1D
*
04BA:  MOVF   7A,W
04BB:  MOVWF  1C
04BC:  MOVF   79,W
04BD:  MOVWF  1B
04BE:  MOVF   78,W
04BF:  MOVWF  1A
04C0:  MOVF   77,W
04C1:  MOVWF  19
04C2:  MOVF   1C,W
04C3:  MOVWF  20
04C4:  MOVF   1B,W
04C5:  MOVWF  1F
04C6:  MOVF   1A,W
04C7:  MOVWF  1E
04C8:  MOVF   19,W
04C9:  MOVWF  1D
04CA:  CLRF   24
04CB:  CLRF   23
04CC:  MOVLW  7A
04CD:  MOVWF  22
04CE:  MOVLW  88
04CF:  MOVWF  21
04D0:  BCF    03.6
04D1:  CALL   2D2
04D2:  MOVF   7A,W
04D3:  BSF    03.6
04D4:  MOVWF  1C
04D5:  MOVF   79,W
04D6:  MOVWF  1B
04D7:  MOVF   78,W
04D8:  MOVWF  1A
04D9:  MOVF   77,W
04DA:  MOVWF  19
04DB:  BCF    03.6
04DC:  CALL   39E
04DD:  MOVF   79,W
04DE:  BSF    03.6
04DF:  MOVWF  16
04E0:  MOVF   78,W
04E1:  MOVWF  15
....................     long period = 1000000 / frequency; // Calcula o perodo em microssegundos 
....................     long halfPeriod = period / 2; // Metade do perodo para o ciclo de trabalho 
....................      
....................     long numCycles = frequency * duration / 1000; // Calcula o nmero de ciclos 
....................      
....................     for (long i = 0; i < numCycles; i++) { 
04E2:  CLRF   18
04E3:  CLRF   17
04E4:  MOVF   18,W
04E5:  SUBWF  16,W
04E6:  BTFSS  03.0
04E7:  GOTO   522
04E8:  BTFSS  03.2
04E9:  GOTO   4EE
04EA:  MOVF   15,W
04EB:  SUBWF  17,W
04EC:  BTFSC  03.0
04ED:  GOTO   522
....................         output_high(BUZZER_PIN); 
04EE:  BCF    03.6
04EF:  BCF    6A.4
04F0:  MOVF   6A,W
04F1:  BSF    03.5
04F2:  MOVWF  07
04F3:  BCF    03.5
04F4:  BSF    07.4
....................         delay_us(halfPeriod); 
04F5:  BSF    03.6
04F6:  MOVF   14,W
04F7:  MOVWF  19
04F8:  INCF   19,F
04F9:  DECF   19,F
04FA:  BTFSC  03.2
04FB:  GOTO   502
04FC:  MOVLW  FF
04FD:  MOVWF  1A
04FE:  BCF    03.6
04FF:  CALL   3BF
0500:  BSF    03.6
0501:  GOTO   4F9
0502:  MOVF   13,W
0503:  MOVWF  1A
0504:  BCF    03.6
0505:  CALL   3BF
....................          
....................         output_low(BUZZER_PIN); 
0506:  BCF    6A.4
0507:  MOVF   6A,W
0508:  BSF    03.5
0509:  MOVWF  07
050A:  BCF    03.5
050B:  BCF    07.4
....................         delay_us(halfPeriod); 
050C:  BSF    03.6
050D:  MOVF   14,W
050E:  MOVWF  19
050F:  INCF   19,F
0510:  DECF   19,F
0511:  BTFSC  03.2
0512:  GOTO   519
0513:  MOVLW  FF
0514:  MOVWF  1A
0515:  BCF    03.6
0516:  CALL   3BF
0517:  BSF    03.6
0518:  GOTO   510
0519:  MOVF   13,W
051A:  MOVWF  1A
051B:  BCF    03.6
051C:  CALL   3BF
051D:  BSF    03.6
051E:  INCF   17,F
051F:  BTFSC  03.2
0520:  INCF   18,F
0521:  GOTO   4E4
....................     } 
0522:  BCF    03.6
0523:  RETURN
.................... } 
.................... //======================================= 
....................  
.................... //============Playseq==================== 
.................... void playSeq(){ 
.................... for(int i = 0; i <= nivel; i++){ 
*
05CC:  CLRF   6C
05CD:  MOVF   6C,W
05CE:  SUBWF  66,W
05CF:  BTFSS  03.0
05D0:  GOTO   656
....................           switch(nivel){ 
05D1:  MOVLW  01
05D2:  SUBWF  66,W
05D3:  ADDLW  FC
05D4:  BTFSC  03.0
05D5:  GOTO   654
05D6:  ADDLW  04
05D7:  GOTO   657
....................           	case 1: 
....................           		playTone(262,2000); 
05D8:  BSF    03.5
05D9:  CLRF   6F
05DA:  CLRF   6E
05DB:  MOVLW  03
05DC:  MOVWF  6D
05DD:  MOVLW  87
05DE:  MOVWF  6C
05DF:  MOVLW  D0
05E0:  BCF    03.5
05E1:  BSF    03.6
05E2:  MOVWF  10
05E3:  BCF    03.6
05E4:  CALL   3D0
....................           		output_high(BLUE); 
05E5:  BSF    03.5
05E6:  BCF    05.0
05E7:  BCF    03.5
05E8:  BSF    05.0
....................           		delay_ms(1000); 
05E9:  MOVLW  04
05EA:  MOVWF  6D
05EB:  MOVLW  FA
05EC:  BSF    03.5
05ED:  MOVWF  6B
05EE:  BCF    03.5
05EF:  CALL   05D
05F0:  DECFSZ 6D,F
05F1:  GOTO   5EB
....................           		output_low(BLUE); 
05F2:  BSF    03.5
05F3:  BCF    05.0
05F4:  BCF    03.5
05F5:  BCF    05.0
....................           		break; 
05F6:  GOTO   654
....................           	case 2: 
....................           		playTone(1200,2000); 
05F7:  BSF    03.5
05F8:  CLRF   6F
05F9:  CLRF   6E
05FA:  MOVLW  16
05FB:  MOVWF  6D
05FC:  MOVLW  89
05FD:  MOVWF  6C
05FE:  MOVLW  D0
05FF:  BCF    03.5
0600:  BSF    03.6
0601:  MOVWF  10
0602:  BCF    03.6
0603:  CALL   3D0
....................           		output_high(GREEN); 
0604:  BSF    03.5
0605:  BCF    05.3
0606:  BCF    03.5
0607:  BSF    05.3
....................           		delay_ms(1000); 
0608:  MOVLW  04
0609:  MOVWF  6D
060A:  MOVLW  FA
060B:  BSF    03.5
060C:  MOVWF  6B
060D:  BCF    03.5
060E:  CALL   05D
060F:  DECFSZ 6D,F
0610:  GOTO   60A
....................           		output_low(GREEN); 
0611:  BSF    03.5
0612:  BCF    05.3
0613:  BCF    03.5
0614:  BCF    05.3
....................           		break; 
0615:  GOTO   654
....................           	case 3: 
....................           		playTone(987,2000); 
0616:  BSF    03.5
0617:  CLRF   6F
0618:  MOVLW  C0
0619:  MOVWF  6E
061A:  MOVLW  76
061B:  MOVWF  6D
061C:  MOVLW  88
061D:  MOVWF  6C
061E:  MOVLW  D0
061F:  BCF    03.5
0620:  BSF    03.6
0621:  MOVWF  10
0622:  BCF    03.6
0623:  CALL   3D0
....................           		output_high(RED); 
0624:  BSF    03.5
0625:  BCF    05.2
0626:  BCF    03.5
0627:  BSF    05.2
....................           		delay_ms(1000); 
0628:  MOVLW  04
0629:  MOVWF  6D
062A:  MOVLW  FA
062B:  BSF    03.5
062C:  MOVWF  6B
062D:  BCF    03.5
062E:  CALL   05D
062F:  DECFSZ 6D,F
0630:  GOTO   62A
....................           		output_low(RED); 
0631:  BSF    03.5
0632:  BCF    05.2
0633:  BCF    03.5
0634:  BCF    05.2
....................           		break; 
0635:  GOTO   654
....................           	case 4: 
....................           		playTone(784,2000); 
0636:  BSF    03.5
0637:  CLRF   6F
0638:  CLRF   6E
0639:  MOVLW  44
063A:  MOVWF  6D
063B:  MOVLW  88
063C:  MOVWF  6C
063D:  MOVLW  D0
063E:  BCF    03.5
063F:  BSF    03.6
0640:  MOVWF  10
0641:  BCF    03.6
0642:  CALL   3D0
....................           		output_high(YELLOW); 
0643:  BSF    03.5
0644:  BCF    05.1
0645:  BCF    03.5
0646:  BSF    05.1
....................           		delay_ms(1000); 
0647:  MOVLW  04
0648:  MOVWF  6D
0649:  MOVLW  FA
064A:  BSF    03.5
064B:  MOVWF  6B
064C:  BCF    03.5
064D:  CALL   05D
064E:  DECFSZ 6D,F
064F:  GOTO   649
....................           		output_low(YELLOW); 
0650:  BSF    03.5
0651:  BCF    05.1
0652:  BCF    03.5
0653:  BCF    05.1
....................           		break; 
....................           } 
0654:  INCF   6C,F
0655:  GOTO   5CD
....................         } 
0656:  RETURN
.................... } 
.................... //======================================= 
.................... //==============leitura de sequencia====== 
.................... void ler_player(){ 
*
065F:  CLRF   6C
.................... 	int press = 0; 
.................... 	for(int i = 0; i <= nivel; i++){ 
0660:  CLRF   6D
0661:  MOVF   6D,W
0662:  SUBWF  66,W
0663:  BTFSS  03.0
0664:  GOTO   6AA
.................... 		while(press == 0){	 
0665:  MOVF   6C,F
0666:  BTFSS  03.2
0667:  GOTO   6A7
....................           if(input(B1)==0){player_seq[i] = 1; press = 1;} 
0668:  BSF    6A.0
0669:  MOVF   6A,W
066A:  BSF    03.5
066B:  MOVWF  07
066C:  BCF    03.5
066D:  BTFSC  07.0
066E:  GOTO   677
066F:  MOVLW  46
0670:  ADDWF  6D,W
0671:  MOVWF  04
0672:  BCF    03.7
0673:  MOVLW  01
0674:  MOVWF  00
0675:  MOVWF  6C
0676:  GOTO   6A6
....................           else if(input(B2)==0){player_seq[i] = 2; press = 1;} 
0677:  BSF    6A.1
0678:  MOVF   6A,W
0679:  BSF    03.5
067A:  MOVWF  07
067B:  BCF    03.5
067C:  BTFSC  07.1
067D:  GOTO   687
067E:  MOVLW  46
067F:  ADDWF  6D,W
0680:  MOVWF  04
0681:  BCF    03.7
0682:  MOVLW  02
0683:  MOVWF  00
0684:  MOVLW  01
0685:  MOVWF  6C
0686:  GOTO   6A6
....................           else if(input(B3)==0){player_seq[i] = 3; press = 1;} 
0687:  BSF    6A.2
0688:  MOVF   6A,W
0689:  BSF    03.5
068A:  MOVWF  07
068B:  BCF    03.5
068C:  BTFSC  07.2
068D:  GOTO   697
068E:  MOVLW  46
068F:  ADDWF  6D,W
0690:  MOVWF  04
0691:  BCF    03.7
0692:  MOVLW  03
0693:  MOVWF  00
0694:  MOVLW  01
0695:  MOVWF  6C
0696:  GOTO   6A6
....................           else if(input(B4)==0){player_seq[i] = 4; press = 1;} 
0697:  BSF    6A.3
0698:  MOVF   6A,W
0699:  BSF    03.5
069A:  MOVWF  07
069B:  BCF    03.5
069C:  BTFSC  07.3
069D:  GOTO   6A6
069E:  MOVLW  46
069F:  ADDWF  6D,W
06A0:  MOVWF  04
06A1:  BCF    03.7
06A2:  MOVLW  04
06A3:  MOVWF  00
06A4:  MOVLW  01
06A5:  MOVWF  6C
06A6:  GOTO   665
....................   }         
....................           press = 0; 
06A7:  CLRF   6C
06A8:  INCF   6D,F
06A9:  GOTO   661
....................           } 
06AA:  BSF    0A.3
06AB:  BCF    0A.4
06AC:  GOTO   07B (RETURN)
.................... } 
.................... //======================================== 
.................... //=============Limpa Display============== 
.................... void limpa_display() { 
....................   lcd_putc("\f"); 
*
02C5:  MOVLW  04
02C6:  BSF    03.6
02C7:  MOVWF  0D
02C8:  MOVLW  00
02C9:  MOVWF  0F
02CA:  BCF    03.6
02CB:  CALL   251
....................   delay_ms(50); 
02CC:  MOVLW  32
02CD:  BSF    03.5
02CE:  MOVWF  6B
02CF:  BCF    03.5
02D0:  CALL   05D
02D1:  RETURN
.................... } 
.................... //======================================== 
.................... //=============Start game=================== 
.................... void start_game(){ 
.................... float notes[] = {659, 783, 987, 659, 783, 987, 1200, 987};		 
*
0524:  MOVLW  88
0525:  BSF    03.5
0526:  MOVWF  20
0527:  MOVLW  24
0528:  MOVWF  21
0529:  MOVLW  C0
052A:  MOVWF  22
052B:  CLRF   23
052C:  MOVLW  88
052D:  MOVWF  24
052E:  MOVLW  43
052F:  MOVWF  25
0530:  MOVLW  C0
0531:  MOVWF  26
0532:  CLRF   27
0533:  MOVLW  88
0534:  MOVWF  28
0535:  MOVLW  76
0536:  MOVWF  29
0537:  MOVLW  C0
0538:  MOVWF  2A
0539:  CLRF   2B
053A:  MOVLW  88
053B:  MOVWF  2C
053C:  MOVLW  24
053D:  MOVWF  2D
053E:  MOVLW  C0
053F:  MOVWF  2E
0540:  CLRF   2F
0541:  MOVLW  88
0542:  MOVWF  30
0543:  MOVLW  43
0544:  MOVWF  31
0545:  MOVLW  C0
0546:  MOVWF  32
0547:  CLRF   33
0548:  MOVLW  88
0549:  MOVWF  34
054A:  MOVLW  76
054B:  MOVWF  35
054C:  MOVLW  C0
054D:  MOVWF  36
054E:  CLRF   37
054F:  MOVLW  89
0550:  MOVWF  38
0551:  MOVLW  16
0552:  MOVWF  39
0553:  CLRF   3A
0554:  CLRF   3B
0555:  MOVLW  88
0556:  MOVWF  3C
0557:  MOVLW  76
0558:  MOVWF  3D
0559:  MOVLW  C0
055A:  MOVWF  3E
055B:  CLRF   3F
.................... int durations[] = {150, 150, 150, 150, 150, 150, 300, 150}; 
055C:  MOVLW  96
055D:  BCF    03.5
055E:  MOVWF  6C
055F:  MOVWF  6D
0560:  MOVWF  6E
0561:  MOVWF  6F
0562:  MOVWF  70
0563:  MOVWF  71
0564:  MOVLW  2C
0565:  MOVWF  72
0566:  MOVLW  96
0567:  MOVWF  73
.................... limpa_display(); 
0568:  CALL   2C5
.................... lcd_gotoxy(1,1); 
0569:  MOVLW  01
056A:  BSF    03.5
056B:  MOVWF  6C
056C:  MOVWF  6D
056D:  BCF    03.5
056E:  CALL   1FB
.................... printf(lcd_putc, "Welcome to Simon"); 
056F:  MOVLW  05
0570:  BSF    03.6
0571:  MOVWF  0D
0572:  MOVLW  00
0573:  MOVWF  0F
0574:  BCF    03.6
0575:  CALL   251
.................... lcd_gotoxy(2,2); 
0576:  MOVLW  02
0577:  BSF    03.5
0578:  MOVWF  6C
0579:  MOVWF  6D
057A:  BCF    03.5
057B:  CALL   1FB
.................... printf(lcd_putc, "Press Start!"); 
057C:  MOVLW  0E
057D:  BSF    03.6
057E:  MOVWF  0D
057F:  MOVLW  00
0580:  MOVWF  0F
0581:  BCF    03.6
0582:  CALL   251
.................... do{ 
.................... for(int i = 0; i < 8; i++){ 
0583:  CLRF   74
0584:  MOVF   74,W
0585:  SUBLW  07
0586:  BTFSS  03.0
0587:  GOTO   5B8
....................         playTone(notes[i], durations[i]); // Toca a nota C4 por 500 ms 
0588:  RLF    74,W
0589:  MOVWF  77
058A:  RLF    77,F
058B:  MOVLW  FC
058C:  ANDWF  77,F
058D:  MOVF   77,W
058E:  ADDLW  A0
058F:  MOVWF  04
0590:  BCF    03.7
0591:  MOVF   00,W
0592:  BSF    03.5
0593:  MOVWF  40
0594:  INCF   04,F
0595:  MOVF   00,W
0596:  MOVWF  41
0597:  INCF   04,F
0598:  MOVF   00,W
0599:  MOVWF  42
059A:  INCF   04,F
059B:  MOVF   00,W
059C:  MOVWF  43
059D:  MOVLW  6C
059E:  ADDWF  74,W
059F:  MOVWF  04
05A0:  BCF    03.7
05A1:  MOVF   00,W
05A2:  MOVWF  44
05A3:  MOVF   43,W
05A4:  MOVWF  6F
05A5:  MOVF   42,W
05A6:  MOVWF  6E
05A7:  MOVF   41,W
05A8:  MOVWF  6D
05A9:  MOVF   40,W
05AA:  MOVWF  6C
05AB:  MOVF   44,W
05AC:  BCF    03.5
05AD:  BSF    03.6
05AE:  MOVWF  10
05AF:  BCF    03.6
05B0:  CALL   3D0
....................          // Pausa de 500 ms entre as notas 
....................          delay_ms(70); 
05B1:  MOVLW  46
05B2:  BSF    03.5
05B3:  MOVWF  6B
05B4:  BCF    03.5
05B5:  CALL   05D
05B6:  INCF   74,F
05B7:  GOTO   584
....................     } 
....................     delay_ms(70); 
05B8:  MOVLW  46
05B9:  BSF    03.5
05BA:  MOVWF  6B
05BB:  BCF    03.5
05BC:  CALL   05D
....................     if(input(START_PIN) == 0){start = 1;} 
05BD:  BSF    6A.5
05BE:  MOVF   6A,W
05BF:  BSF    03.5
05C0:  MOVWF  07
05C1:  BCF    03.5
05C2:  BTFSC  07.5
05C3:  GOTO   5C6
05C4:  MOVLW  01
05C5:  MOVWF  67
.................... }while(start == 0) ;   
05C6:  MOVF   67,F
05C7:  BTFSC  03.2
05C8:  GOTO   583
05C9:  BSF    0A.3
05CA:  BCF    0A.4
05CB:  GOTO   02A (RETURN)
.................... } 
.................... //========================================== 
....................  
.................... //================GAME OVER================= 
.................... void game_over(){ 
.................... 	int durations[] = {100, 100, 100, 100, 100, 100,100, 100, 100, 100, 100, 100, 400, 400}; 
*
06AD:  MOVLW  64
06AE:  BSF    03.5
06AF:  MOVWF  20
06B0:  MOVWF  21
06B1:  MOVWF  22
06B2:  MOVWF  23
06B3:  MOVWF  24
06B4:  MOVWF  25
06B5:  MOVWF  26
06B6:  MOVWF  27
06B7:  MOVWF  28
06B8:  MOVWF  29
06B9:  MOVWF  2A
06BA:  MOVWF  2B
06BB:  MOVLW  90
06BC:  MOVWF  2C
06BD:  MOVWF  2D
....................     float errado[] = {523, 392, 330, 440, 494, 440, 415, 466, 415, 
.................... 392, 294, 330, 392, 392}; 
06BE:  MOVLW  88
06BF:  MOVWF  2E
06C0:  MOVLW  02
06C1:  MOVWF  2F
06C2:  MOVLW  C0
06C3:  MOVWF  30
06C4:  CLRF   31
06C5:  MOVLW  87
06C6:  MOVWF  32
06C7:  MOVLW  44
06C8:  MOVWF  33
06C9:  CLRF   34
06CA:  CLRF   35
06CB:  MOVLW  87
06CC:  MOVWF  36
06CD:  MOVLW  25
06CE:  MOVWF  37
06CF:  CLRF   38
06D0:  CLRF   39
06D1:  MOVLW  87
06D2:  MOVWF  3A
06D3:  MOVLW  5C
06D4:  MOVWF  3B
06D5:  CLRF   3C
06D6:  CLRF   3D
06D7:  MOVLW  87
06D8:  MOVWF  3E
06D9:  MOVLW  77
06DA:  MOVWF  3F
06DB:  CLRF   40
06DC:  CLRF   41
06DD:  MOVLW  87
06DE:  MOVWF  42
06DF:  MOVLW  5C
06E0:  MOVWF  43
06E1:  CLRF   44
06E2:  CLRF   45
06E3:  MOVLW  87
06E4:  MOVWF  46
06E5:  MOVLW  4F
06E6:  MOVWF  47
06E7:  MOVLW  80
06E8:  MOVWF  48
06E9:  CLRF   49
06EA:  MOVLW  87
06EB:  MOVWF  4A
06EC:  MOVLW  69
06ED:  MOVWF  4B
06EE:  CLRF   4C
06EF:  CLRF   4D
06F0:  MOVLW  87
06F1:  MOVWF  4E
06F2:  MOVLW  4F
06F3:  MOVWF  4F
06F4:  MOVLW  80
06F5:  MOVWF  50
06F6:  CLRF   51
06F7:  MOVLW  87
06F8:  MOVWF  52
06F9:  MOVLW  44
06FA:  MOVWF  53
06FB:  CLRF   54
06FC:  CLRF   55
06FD:  MOVLW  87
06FE:  MOVWF  56
06FF:  MOVLW  13
0700:  MOVWF  57
0701:  CLRF   58
0702:  CLRF   59
0703:  MOVLW  87
0704:  MOVWF  5A
0705:  MOVLW  25
0706:  MOVWF  5B
0707:  CLRF   5C
0708:  CLRF   5D
0709:  MOVLW  87
070A:  MOVWF  5E
070B:  MOVLW  44
070C:  MOVWF  5F
070D:  CLRF   60
070E:  CLRF   61
070F:  MOVLW  87
0710:  MOVWF  62
0711:  MOVLW  44
0712:  MOVWF  63
0713:  CLRF   64
0714:  CLRF   65
.................... limpa_display(); 
0715:  BCF    03.5
0716:  CALL   2C5
.................... lcd_gotoxy(3,1); 
0717:  MOVLW  03
0718:  BSF    03.5
0719:  MOVWF  6C
071A:  MOVLW  01
071B:  MOVWF  6D
071C:  BCF    03.5
071D:  CALL   1FB
.................... printf(lcd_putc, "GAME OVER!"); 
071E:  MOVLW  15
071F:  BSF    03.6
0720:  MOVWF  0D
0721:  MOVLW  00
0722:  MOVWF  0F
0723:  BCF    03.6
0724:  CALL   251
.................... for(int i = 0; i < 14; i++){ 
0725:  CLRF   6C
0726:  MOVF   6C,W
0727:  SUBLW  0D
0728:  BTFSS  03.0
0729:  GOTO   760
....................         playTone(errado[i], durations[i]); // Toca a nota C4 por 500 ms 
072A:  RLF    6C,W
072B:  MOVWF  77
072C:  RLF    77,F
072D:  MOVLW  FC
072E:  ANDWF  77,F
072F:  MOVF   77,W
0730:  ADDLW  AE
0731:  MOVWF  04
0732:  BCF    03.7
0733:  MOVF   00,W
0734:  MOVWF  6D
0735:  INCF   04,F
0736:  MOVF   00,W
0737:  MOVWF  6E
0738:  INCF   04,F
0739:  MOVF   00,W
073A:  MOVWF  6F
073B:  INCF   04,F
073C:  MOVF   00,W
073D:  MOVWF  70
073E:  MOVLW  A0
073F:  ADDWF  6C,W
0740:  MOVWF  04
0741:  BCF    03.7
0742:  MOVF   00,W
0743:  MOVWF  71
0744:  MOVF   70,W
0745:  BSF    03.5
0746:  MOVWF  6F
0747:  BCF    03.5
0748:  MOVF   6F,W
0749:  BSF    03.5
074A:  MOVWF  6E
074B:  BCF    03.5
074C:  MOVF   6E,W
074D:  BSF    03.5
074E:  MOVWF  6D
074F:  BCF    03.5
0750:  MOVF   6D,W
0751:  BSF    03.5
0752:  MOVWF  6C
0753:  MOVF   71,W
0754:  BCF    03.5
0755:  BSF    03.6
0756:  MOVWF  10
0757:  BCF    03.6
0758:  CALL   3D0
....................          // Pausa de 500 ms entre as notas 
....................          delay_ms(50); 
0759:  MOVLW  32
075A:  BSF    03.5
075B:  MOVWF  6B
075C:  BCF    03.5
075D:  CALL   05D
075E:  INCF   6C,F
075F:  GOTO   726
....................     }   
....................  
.................... delay_ms(1000); 
0760:  MOVLW  04
0761:  MOVWF  6D
0762:  MOVLW  FA
0763:  BSF    03.5
0764:  MOVWF  6B
0765:  BCF    03.5
0766:  CALL   05D
0767:  DECFSZ 6D,F
0768:  GOTO   762
0769:  BSF    0A.3
076A:  BCF    0A.4
076B:  GOTO   19B (RETURN)
.................... } 
.................... //========================================== 
.................... //+++++++++++++INICIATE THE VECTOR+++++++++++++++++ 
.................... void init_seq(){ 
....................  
.................... for(int i = 0; i < 32; i++){ 
*
012A:  CLRF   6C
012B:  MOVF   6C,W
012C:  SUBLW  1F
012D:  BTFSS  03.0
012E:  GOTO   13B
....................   seq[i] = 0; 
012F:  MOVLW  26
0130:  ADDWF  6C,W
0131:  MOVWF  04
0132:  BCF    03.7
0133:  CLRF   00
....................   player_seq[i] = 0; 
0134:  MOVLW  46
0135:  ADDWF  6C,W
0136:  MOVWF  04
0137:  BCF    03.7
0138:  CLRF   00
0139:  INCF   6C,F
013A:  GOTO   12B
.................... } 
013B:  BSF    0A.3
013C:  BCF    0A.4
013D:  GOTO   024 (RETURN)
....................    
.................... } 
.................... //+++++++++++++++++++++++++++++++++++++++++++++++++ 
....................  
.................... //++++++++++++++++GENERATE SEQUENCE++++++++++++++++ 
.................... void gerar_seq(){ 
.................... for(int i = 0; i < 32; i=i+2){ 
013E:  CLRF   6C
013F:  MOVF   6C,W
0140:  SUBLW  1F
0141:  BTFSS  03.0
0142:  GOTO   1F8
....................   seq[i] = (rand()%4)+1; 
0143:  MOVLW  26
0144:  ADDWF  6C,W
0145:  MOVWF  78
0146:  CLRF   7A
0147:  BTFSC  03.0
0148:  INCF   7A,F
0149:  MOVF   78,W
014A:  MOVWF  6D
014B:  MOVF   7A,W
014C:  MOVWF  6E
*
01E0:  MOVF   79,W
01E1:  MOVWF  70
01E2:  MOVF   78,W
01E3:  MOVWF  6F
01E4:  MOVLW  03
01E5:  ANDWF  6F,F
01E6:  CLRF   70
01E7:  MOVLW  01
01E8:  ADDWF  6F,W
01E9:  MOVWF  78
01EA:  MOVF   70,W
01EB:  MOVWF  7A
01EC:  BTFSC  03.0
01ED:  INCF   7A,F
01EE:  MOVF   6D,W
01EF:  MOVWF  04
01F0:  BCF    03.7
01F1:  BTFSC  6E.0
01F2:  BSF    03.7
01F3:  MOVF   78,W
01F4:  MOVWF  00
01F5:  MOVLW  02
01F6:  ADDWF  6C,F
01F7:  GOTO   13F
.................... } 
01F8:  BSF    0A.3
01F9:  BCF    0A.4
01FA:  GOTO   027 (RETURN)
....................    
.................... } 
.................... //+++++++++++++++++++++++++++++++++++++++++++++++++ 
.................... /* 
.................... * Apresentar sequencia 
.................... * Comparar 
.................... * Igual = dar os parabens; Diferente = fala que errou e apresenta a certa 
.................... Se errou start = 0 
.................... * Condicional se nivel for impar pedir um valor de 1 a 4 e guarda na  
.................... array seq 
.................... */ 
....................  
....................  
.................... void main(){ 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   66
0804:  CLRF   67
0805:  CLRF   68
0806:  CLRF   69
0807:  MOVLW  FF
0808:  MOVWF  6A
0809:  BCF    03.7
*
0812:  MOVLW  07
0813:  MOVWF  1C
0814:  BCF    03.7
.................... set_tris_a(0b00000000); 
0815:  MOVLW  00
0816:  MOVWF  05
.................... set_tris_c(0b00101111); 
0817:  MOVLW  2F
0818:  MOVWF  07
0819:  BCF    03.5
081A:  MOVWF  6A
.................... //set_tris_b(0b00000000); 
.................... int i = 0; 
081B:  CLRF   6B
.................... lcd_init(); 
081C:  BCF    0A.3
081D:  GOTO   0E0
081E:  BSF    0A.3
....................     while(TRUE){ 
....................       if(start==0){ 
081F:  MOVF   67,F
0820:  BTFSS  03.2
0821:  GOTO   02C
....................       init_seq(); 
0822:  BCF    0A.3
0823:  GOTO   12A
0824:  BSF    0A.3
....................       gerar_seq(); 
0825:  BCF    0A.3
0826:  GOTO   13E
0827:  BSF    0A.3
....................       start_game(); 
0828:  BCF    0A.3
0829:  GOTO   524
082A:  BSF    0A.3
....................         nivel = 0; 
082B:  CLRF   66
....................       } 
....................       if(start==1){ 
082C:  DECFSZ 67,W
082D:  GOTO   19D
....................         //play_seq 
....................         //printf("\nApresentando Sequencia\n\n"); 
....................         limpa_display(); 
082E:  BCF    0A.3
082F:  CALL   2C5
0830:  BSF    0A.3
....................         lcd_gotoxy(1,1); 
0831:  MOVLW  01
0832:  BSF    03.5
0833:  MOVWF  6C
0834:  MOVWF  6D
0835:  BCF    0A.3
0836:  BCF    03.5
0837:  CALL   1FB
0838:  BSF    0A.3
....................         printf(lcd_putc, "Showing the seq!"); 
0839:  MOVLW  1B
083A:  BSF    03.6
083B:  MOVWF  0D
083C:  MOVLW  00
083D:  MOVWF  0F
083E:  BCF    0A.3
083F:  BCF    03.6
0840:  CALL   251
0841:  BSF    0A.3
....................         playSeq(); 
0842:  BCF    0A.3
0843:  CALL   5CC
0844:  BSF    0A.3
....................         //vez do compitador 
....................         if(nivel%2 != 0){ 
0845:  MOVF   66,W
0846:  ANDLW  01
0847:  BTFSC  03.2
0848:  GOTO   060
....................           //printf("\n\nVez do comp\n\n"); 
....................           //play_seq 
....................         limpa_display(); 
0849:  BCF    0A.3
084A:  CALL   2C5
084B:  BSF    0A.3
....................         lcd_gotoxy(1,1); 
084C:  MOVLW  01
084D:  BSF    03.5
084E:  MOVWF  6C
084F:  MOVWF  6D
0850:  BCF    0A.3
0851:  BCF    03.5
0852:  CALL   1FB
0853:  BSF    0A.3
....................         printf(lcd_putc, "Now it's Simon!"); 
0854:  MOVLW  24
0855:  BSF    03.6
0856:  MOVWF  0D
0857:  MOVLW  00
0858:  MOVWF  0F
0859:  BCF    0A.3
085A:  BCF    03.6
085B:  CALL   251
085C:  BSF    0A.3
....................           playSeq(); 
085D:  BCF    0A.3
085E:  CALL   5CC
085F:  BSF    0A.3
....................           
....................         } 
....................         if(nivel%2 == 0){ 
0860:  MOVF   66,W
0861:  ANDLW  01
0862:  BTFSS  03.2
0863:  GOTO   19C
....................         limpa_display(); 
0864:  BCF    0A.3
0865:  CALL   2C5
0866:  BSF    0A.3
....................         lcd_gotoxy(2,1); 
0867:  MOVLW  02
0868:  BSF    03.5
0869:  MOVWF  6C
086A:  MOVLW  01
086B:  MOVWF  6D
086C:  BCF    0A.3
086D:  BCF    03.5
086E:  CALL   1FB
086F:  BSF    0A.3
....................         printf(lcd_putc, "Now it's You!"); 
0870:  MOVLW  2C
0871:  BSF    03.6
0872:  MOVWF  0D
0873:  MOVLW  00
0874:  MOVWF  0F
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   251
0878:  BSF    0A.3
....................         ler_player(); 
0879:  BCF    0A.3
087A:  GOTO   65F
087B:  BSF    0A.3
....................           
....................         for( i = 0; i <= nivel; i++){ 
087C:  CLRF   6B
087D:  MOVF   6B,W
087E:  SUBWF  66,W
087F:  BTFSS  03.0
0880:  GOTO   0A5
....................  
....................           if(seq[i]==player_seq[i]){ 
0881:  MOVLW  26
0882:  ADDWF  6B,W
0883:  MOVWF  04
0884:  BCF    03.7
0885:  MOVF   00,W
0886:  MOVWF  6C
0887:  MOVLW  46
0888:  ADDWF  6B,W
0889:  MOVWF  04
088A:  BCF    03.7
088B:  MOVF   00,W
088C:  SUBWF  6C,W
088D:  BTFSS  03.2
088E:  GOTO   091
....................           acertou = 1; 
088F:  MOVLW  01
0890:  MOVWF  68
....................           } 
....................           if(seq[i]!=player_seq[i]){ 
0891:  MOVLW  26
0892:  ADDWF  6B,W
0893:  MOVWF  04
0894:  BCF    03.7
0895:  MOVF   00,W
0896:  MOVWF  6C
0897:  MOVLW  46
0898:  ADDWF  6B,W
0899:  MOVWF  04
089A:  BCF    03.7
089B:  MOVF   00,W
089C:  SUBWF  6C,W
089D:  BTFSC  03.2
089E:  GOTO   0A3
....................           errou = 1; 
089F:  MOVLW  01
08A0:  MOVWF  69
....................           acertou = 0; 
08A1:  CLRF   68
....................           break; 
08A2:  GOTO   0A5
....................         } 
08A3:  INCF   6B,F
08A4:  GOTO   07D
....................         }   
....................           if(acertou==1){ 
08A5:  DECFSZ 68,W
08A6:  GOTO   194
....................             limpa_display(); 
08A7:  BCF    0A.3
08A8:  CALL   2C5
08A9:  BSF    0A.3
....................         	lcd_gotoxy(1,1); 
08AA:  MOVLW  01
08AB:  BSF    03.5
08AC:  MOVWF  6C
08AD:  MOVWF  6D
08AE:  BCF    0A.3
08AF:  BCF    03.5
08B0:  CALL   1FB
08B1:  BSF    0A.3
....................         	printf(lcd_putc, "U got it right!"); 
08B2:  MOVLW  33
08B3:  BSF    03.6
08B4:  MOVWF  0D
08B5:  MOVLW  00
08B6:  MOVWF  0F
08B7:  BCF    0A.3
08B8:  BCF    03.6
08B9:  CALL   251
08BA:  BSF    0A.3
....................             if((nivel+1)%2!=0){ 
08BB:  MOVLW  01
08BC:  ADDWF  66,W
08BD:  ANDLW  01
08BE:  BTFSC  03.2
08BF:  GOTO   193
.................... 	        limpa_display(); 
08C0:  BCF    0A.3
08C1:  CALL   2C5
08C2:  BSF    0A.3
....................         	lcd_gotoxy(1,1); 
08C3:  MOVLW  01
08C4:  BSF    03.5
08C5:  MOVWF  6C
08C6:  MOVWF  6D
08C7:  BCF    0A.3
08C8:  BCF    03.5
08C9:  CALL   1FB
08CA:  BSF    0A.3
....................         	printf(lcd_putc, "It's ur turn!:)"); 
08CB:  MOVLW  3B
08CC:  BSF    03.6
08CD:  MOVWF  0D
08CE:  MOVLW  00
08CF:  MOVWF  0F
08D0:  BCF    0A.3
08D1:  BCF    03.6
08D2:  CALL   251
08D3:  BSF    0A.3
....................         	lcd_gotoxy(1,2); 
08D4:  MOVLW  01
08D5:  BSF    03.5
08D6:  MOVWF  6C
08D7:  MOVLW  02
08D8:  MOVWF  6D
08D9:  BCF    0A.3
08DA:  BCF    03.5
08DB:  CALL   1FB
08DC:  BSF    0A.3
....................         	printf(lcd_putc, "Enter a value"); 
08DD:  MOVLW  43
08DE:  BSF    03.6
08DF:  MOVWF  0D
08E0:  MOVLW  00
08E1:  MOVWF  0F
08E2:  BCF    0A.3
08E3:  BCF    03.6
08E4:  CALL   251
08E5:  BSF    0A.3
....................         	delay_ms(2000); 
08E6:  MOVLW  08
08E7:  MOVWF  6C
08E8:  MOVLW  FA
08E9:  BSF    03.5
08EA:  MOVWF  6B
08EB:  BCF    0A.3
08EC:  BCF    03.5
08ED:  CALL   05D
08EE:  BSF    0A.3
08EF:  DECFSZ 6C,F
08F0:  GOTO   0E8
....................         	limpa_display(); 
08F1:  BCF    0A.3
08F2:  CALL   2C5
08F3:  BSF    0A.3
....................         	lcd_gotoxy(1,1); 
08F4:  MOVLW  01
08F5:  BSF    03.5
08F6:  MOVWF  6C
08F7:  MOVWF  6D
08F8:  BCF    0A.3
08F9:  BCF    03.5
08FA:  CALL   1FB
08FB:  BSF    0A.3
....................         	printf(lcd_putc, "to add to the"); 
08FC:  MOVLW  4A
08FD:  BSF    03.6
08FE:  MOVWF  0D
08FF:  MOVLW  00
0900:  MOVWF  0F
0901:  BCF    0A.3
0902:  BCF    03.6
0903:  CALL   251
0904:  BSF    0A.3
....................         	lcd_gotoxy(1,2); 
0905:  MOVLW  01
0906:  BSF    03.5
0907:  MOVWF  6C
0908:  MOVLW  02
0909:  MOVWF  6D
090A:  BCF    0A.3
090B:  BCF    03.5
090C:  CALL   1FB
090D:  BSF    0A.3
....................         	printf(lcd_putc, "sequence!"); 
090E:  MOVLW  51
090F:  BSF    03.6
0910:  MOVWF  0D
0911:  MOVLW  00
0912:  MOVWF  0F
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   251
0916:  BSF    0A.3
....................             delay_ms(2000); 
0917:  MOVLW  08
0918:  MOVWF  6C
0919:  MOVLW  FA
091A:  BSF    03.5
091B:  MOVWF  6B
091C:  BCF    0A.3
091D:  BCF    03.5
091E:  CALL   05D
091F:  BSF    0A.3
0920:  DECFSZ 6C,F
0921:  GOTO   119
....................             limpa_display(); 
0922:  BCF    0A.3
0923:  CALL   2C5
0924:  BSF    0A.3
....................             lcd_gotoxy(1,1); 
0925:  MOVLW  01
0926:  BSF    03.5
0927:  MOVWF  6C
0928:  MOVWF  6D
0929:  BCF    0A.3
092A:  BCF    03.5
092B:  CALL   1FB
092C:  BSF    0A.3
....................         	printf(lcd_putc, "Press one! :)"); 
092D:  MOVLW  56
092E:  BSF    03.6
092F:  MOVWF  0D
0930:  MOVLW  00
0931:  MOVWF  0F
0932:  BCF    0A.3
0933:  BCF    03.6
0934:  CALL   251
0935:  BSF    0A.3
....................           while(input(BLUE) == 1 && input(GREEN) == 1 && input(RED) == 1 && input(YELLOW) == 1){	 
0936:  BSF    03.5
0937:  BSF    05.0
0938:  BCF    03.5
0939:  BTFSS  05.0
093A:  GOTO   17E
093B:  BSF    03.5
093C:  BSF    05.3
093D:  BCF    03.5
093E:  BTFSS  05.3
093F:  GOTO   17E
0940:  BSF    03.5
0941:  BSF    05.2
0942:  BCF    03.5
0943:  BTFSS  05.2
0944:  GOTO   17E
0945:  BSF    03.5
0946:  BSF    05.1
0947:  BCF    03.5
0948:  BTFSS  05.1
0949:  GOTO   17E
....................           if(input(BLUE)==0){player_seq[nivel+1] = 1;} 
094A:  BSF    03.5
094B:  BSF    05.0
094C:  BCF    03.5
094D:  BTFSC  05.0
094E:  GOTO   157
094F:  MOVLW  01
0950:  ADDWF  66,W
0951:  ADDLW  46
0952:  MOVWF  04
0953:  BCF    03.7
0954:  MOVLW  01
0955:  MOVWF  00
0956:  GOTO   17D
....................           else if(input(GREEN)==0){player_seq[nivel+1] = 2;} 
0957:  BSF    03.5
0958:  BSF    05.3
0959:  BCF    03.5
095A:  BTFSC  05.3
095B:  GOTO   164
095C:  MOVLW  01
095D:  ADDWF  66,W
095E:  ADDLW  46
095F:  MOVWF  04
0960:  BCF    03.7
0961:  MOVLW  02
0962:  MOVWF  00
0963:  GOTO   17D
....................           else if(input(RED)==0){player_seq[nivel+1] = 3;} 
0964:  BSF    03.5
0965:  BSF    05.2
0966:  BCF    03.5
0967:  BTFSC  05.2
0968:  GOTO   171
0969:  MOVLW  01
096A:  ADDWF  66,W
096B:  ADDLW  46
096C:  MOVWF  04
096D:  BCF    03.7
096E:  MOVLW  03
096F:  MOVWF  00
0970:  GOTO   17D
....................           else if(input(YELLOW)==0){player_seq[nivel+1] = 4;} 
0971:  BSF    03.5
0972:  BSF    05.1
0973:  BCF    03.5
0974:  BTFSC  05.1
0975:  GOTO   17D
0976:  MOVLW  01
0977:  ADDWF  66,W
0978:  ADDLW  46
0979:  MOVWF  04
097A:  BCF    03.7
097B:  MOVLW  04
097C:  MOVWF  00
097D:  GOTO   136
....................   }  
....................           seq[nivel+1] = player_seq[nivel+1]; 
097E:  MOVLW  01
097F:  ADDWF  66,W
0980:  ADDLW  26
0981:  MOVWF  6C
0982:  CLRF   6D
0983:  BTFSC  03.0
0984:  INCF   6D,F
0985:  MOVLW  01
0986:  ADDWF  66,W
0987:  ADDLW  46
0988:  MOVWF  04
0989:  BCF    03.7
098A:  MOVF   00,W
098B:  MOVWF  6E
098C:  MOVF   6C,W
098D:  MOVWF  04
098E:  BCF    03.7
098F:  BTFSC  6D.0
0990:  BSF    03.7
0991:  MOVF   6E,W
0992:  MOVWF  00
....................           } 
....................             acertou = 0; 
0993:  CLRF   68
....................              
....................           } 
....................           if(errou == 1){ 
0994:  DECFSZ 69,W
0995:  GOTO   19C
....................             acertou = 0; 
0996:  CLRF   68
....................             start = 0; 
0997:  CLRF   67
....................             errou = 0; 
0998:  CLRF   69
....................             game_over(); 
0999:  BCF    0A.3
099A:  GOTO   6AD
099B:  BSF    0A.3
....................             //break; 
....................           } 
....................             
....................         } 
....................          nivel++;  
099C:  INCF   66,F
....................         } 
099D:  GOTO   01F
....................          
....................         } 
....................          
.................... } 
....................  
099E:  SLEEP
.................... #import(file="lcd.o") 
.................... #device PIC16F877A 
.................... #use delay(clock = 20000000) 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0090:  MOVLW  0F
0091:  BSF    03.5
0092:  ANDWF  08,W
0093:  IORLW  F0
0094:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0095:  BCF    03.5
0096:  BSF    08.2
....................    delay_cycles(1); 
0097:  NOP
....................    lcd_output_enable(1); 
0098:  BSF    08.0
....................    delay_cycles(1); 
0099:  NOP
....................    high = lcd_read_nibble(); 
009A:  CALL   084
009B:  MOVF   78,W
009C:  BSF    03.6
009D:  MOVWF  14
....................        
....................    lcd_output_enable(0); 
009E:  BCF    03.6
009F:  BCF    08.0
....................    delay_cycles(1); 
00A0:  NOP
....................    lcd_output_enable(1); 
00A1:  BSF    08.0
....................    delay_us(1); 
00A2:  GOTO   0A3
00A3:  GOTO   0A4
00A4:  NOP
....................    low = lcd_read_nibble(); 
00A5:  CALL   084
00A6:  MOVF   78,W
00A7:  BSF    03.6
00A8:  MOVWF  13
....................        
....................    lcd_output_enable(0); 
00A9:  BCF    03.6
00AA:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00AB:  MOVLW  0F
00AC:  BSF    03.5
00AD:  ANDWF  08,W
00AE:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00AF:  BCF    03.5
00B0:  BSF    03.6
00B1:  SWAPF  14,W
00B2:  MOVWF  77
00B3:  MOVLW  F0
00B4:  ANDWF  77,F
00B5:  MOVF   77,W
00B6:  IORWF  13,W
00B7:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0084:  MOVF   08,W
0085:  MOVWF  77
0086:  SWAPF  08,W
0087:  ANDLW  0F
0088:  MOVWF  78
....................   #endif 
0089:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0071:  BSF    03.6
0072:  SWAPF  12,W
0073:  ANDLW  F0
0074:  MOVWF  77
0075:  MOVLW  0F
0076:  BCF    03.6
0077:  ANDWF  08,W
0078:  IORWF  77,W
0079:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
007A:  NOP
....................    lcd_output_enable(1); 
007B:  BSF    08.0
....................    delay_us(2); 
007C:  MOVLW  02
007D:  MOVWF  77
007E:  DECFSZ 77,F
007F:  GOTO   07E
0080:  GOTO   081
0081:  NOP
....................    lcd_output_enable(0); 
0082:  BCF    08.0
0083:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
008A:  BSF    03.5
008B:  BCF    08.0
....................    lcd_rs_tris(); 
008C:  BCF    08.1
....................    lcd_rw_tris(); 
008D:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
008E:  BCF    03.5
008F:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00B8:  MOVF   78,W
00B9:  MOVWF  11
00BA:  BTFSS  11.7
00BB:  GOTO   0BE
00BC:  BCF    03.6
00BD:  GOTO   090
....................    lcd_output_rs(address); 
00BE:  BSF    03.5
00BF:  BCF    03.6
00C0:  BTFSC  6F.0
00C1:  GOTO   0C5
00C2:  BCF    03.5
00C3:  BCF    08.1
00C4:  BSF    03.5
00C5:  BTFSS  6F.0
00C6:  GOTO   0CA
00C7:  BCF    03.5
00C8:  BSF    08.1
00C9:  BSF    03.5
....................    delay_cycles(1); 
00CA:  NOP
....................    lcd_output_rw(0); 
00CB:  BCF    03.5
00CC:  BCF    08.2
....................    delay_cycles(1); 
00CD:  NOP
....................    lcd_output_enable(0); 
00CE:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
00CF:  BSF    03.6
00D0:  SWAPF  10,W
00D1:  MOVWF  11
00D2:  MOVLW  0F
00D3:  ANDWF  11,F
00D4:  MOVF   11,W
00D5:  MOVWF  12
00D6:  BCF    03.6
00D7:  CALL   071
....................    lcd_send_nibble(n & 0xf); 
00D8:  BSF    03.6
00D9:  MOVF   10,W
00DA:  ANDLW  0F
00DB:  MOVWF  11
00DC:  MOVWF  12
00DD:  BCF    03.6
00DE:  CALL   071
00DF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00E0:  MOVLW  28
00E1:  MOVWF  72
00E2:  MOVLW  0C
00E3:  MOVWF  73
00E4:  MOVLW  01
00E5:  MOVWF  74
00E6:  MOVLW  06
00E7:  MOVWF  75
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00E8:  BCF    08.0
....................    lcd_output_rs(0); 
00E9:  BCF    08.1
....................    lcd_output_rw(0); 
00EA:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00EB:  MOVLW  0F
00EC:  BSF    03.5
00ED:  ANDWF  08,W
00EE:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00EF:  BCF    08.0
....................    lcd_rs_tris(); 
00F0:  BCF    08.1
....................    lcd_rw_tris(); 
00F1:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
00F2:  MOVLW  0F
00F3:  MOVWF  6B
00F4:  BCF    03.5
00F5:  CALL   05D
....................    for(i=1;i<=3;++i) 
00F6:  MOVLW  01
00F7:  MOVWF  71
00F8:  MOVF   71,W
00F9:  SUBLW  03
00FA:  BTFSS  03.0
00FB:  GOTO   108
....................    { 
....................        lcd_send_nibble(3); 
00FC:  MOVLW  03
00FD:  BSF    03.6
00FE:  MOVWF  12
00FF:  BCF    03.6
0100:  CALL   071
....................        delay_ms(5); 
0101:  MOVLW  05
0102:  BSF    03.5
0103:  MOVWF  6B
0104:  BCF    03.5
0105:  CALL   05D
0106:  INCF   71,F
0107:  GOTO   0F8
....................    } 
....................     
....................    lcd_send_nibble(2); 
0108:  MOVLW  02
0109:  BSF    03.6
010A:  MOVWF  12
010B:  BCF    03.6
010C:  CALL   071
....................    delay_ms(5); 
010D:  MOVLW  05
010E:  BSF    03.5
010F:  MOVWF  6B
0110:  BCF    03.5
0111:  CALL   05D
....................    for(i=0;i<=3;++i) 
0112:  CLRF   71
0113:  MOVF   71,W
0114:  SUBLW  03
0115:  BTFSS  03.0
0116:  GOTO   127
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0117:  MOVLW  72
0118:  ADDWF  71,W
0119:  MOVWF  04
011A:  BCF    03.7
011B:  MOVF   00,W
011C:  MOVWF  76
011D:  BSF    03.5
011E:  CLRF   6F
011F:  MOVF   76,W
0120:  BCF    03.5
0121:  BSF    03.6
0122:  MOVWF  10
0123:  BCF    03.6
0124:  CALL   08A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0125:  INCF   71,F
0126:  GOTO   113
0127:  BSF    0A.3
0128:  BCF    0A.4
0129:  GOTO   01E (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01FB:  BSF    03.5
01FC:  DECFSZ 6D,W
01FD:  GOTO   1FF
01FE:  GOTO   202
....................       address=LCD_LINE_TWO; 
01FF:  MOVLW  40
0200:  MOVWF  6E
0201:  GOTO   203
....................    else 
....................       address=0; 
0202:  CLRF   6E
....................       
....................    address+=x-1; 
0203:  MOVLW  01
0204:  SUBWF  6C,W
0205:  ADDWF  6E,F
....................    lcd_send_byte(0,0x80|address); 
0206:  MOVF   6E,W
0207:  IORLW  80
0208:  MOVWF  6F
0209:  CLRF   6F
020A:  MOVF   6F,W
020B:  BCF    03.5
020C:  BSF    03.6
020D:  MOVWF  10
020E:  BCF    03.6
020F:  CALL   08A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0210:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0211:  BSF    03.5
0212:  MOVF   6A,W
0213:  XORLW  07
0214:  BCF    03.5
0215:  BTFSC  03.2
0216:  GOTO   221
0217:  XORLW  0B
0218:  BTFSC  03.2
0219:  GOTO   228
021A:  XORLW  06
021B:  BTFSC  03.2
021C:  GOTO   236
021D:  XORLW  02
021E:  BTFSC  03.2
021F:  GOTO   23E
0220:  GOTO   247
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0221:  MOVLW  01
0222:  BSF    03.5
0223:  MOVWF  6C
0224:  MOVWF  6D
0225:  BCF    03.5
0226:  CALL   1FB
0227:  GOTO   250
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0228:  BSF    03.5
0229:  CLRF   6F
022A:  MOVLW  01
022B:  BCF    03.5
022C:  BSF    03.6
022D:  MOVWF  10
022E:  BCF    03.6
022F:  CALL   08A
....................                      delay_ms(2); 
0230:  MOVLW  02
0231:  BSF    03.5
0232:  MOVWF  6B
0233:  BCF    03.5
0234:  CALL   05D
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0235:  GOTO   250
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0236:  MOVLW  01
0237:  BSF    03.5
0238:  MOVWF  6C
0239:  MOVLW  02
023A:  MOVWF  6D
023B:  BCF    03.5
023C:  CALL   1FB
023D:  GOTO   250
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
023E:  BSF    03.5
023F:  CLRF   6F
0240:  MOVLW  10
0241:  BCF    03.5
0242:  BSF    03.6
0243:  MOVWF  10
0244:  BCF    03.6
0245:  CALL   08A
0246:  GOTO   250
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0247:  MOVLW  01
0248:  BSF    03.5
0249:  MOVWF  6F
024A:  MOVF   6A,W
024B:  BCF    03.5
024C:  BSF    03.6
024D:  MOVWF  10
024E:  BCF    03.6
024F:  CALL   08A
....................      #endif 
....................    } 
0250:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
